#ifndef LCC_SPECIALOPS_H
#define LCC_SPECIALOPS_H

#include "typedefs.h"

#define M_PI 3.141592654

/// Inexact Primitives
typedef typename LCC::Traits::Point                                         Point;
typedef typename LCC::Traits::Vector                                        Vector;
typedef typename LCC::Traits::Plane_3                                       Plane;
typedef CGAL::Bbox_3                                                        Bbox_3;

typedef unsigned int                                                        uint;
typedef std::string                                                         str;
typedef std::vector<str>                                                    vec_str;
typedef std::pair<str,str>                                                  str_pair;
typedef std::vector<Point>                                             vec_pt3d;
typedef std::vector <Dart_handle>                                           vec_dart;

extern double eps2,
       eps_angle,
       coplanarity;
extern Point global_shift_pt;

namespace LCCtools
{

    /// //////////////////////////////////////////////////////////////////////////////
    /// Convenient functions
    /// //////////////////////////////////////////////////////////////////////////////
    /// to be able to compare const char* in maps

    struct cmp_const_char
    {
       bool operator()(const char *a, const char *b) const
       {
          return std::strcmp(a, b) < 0;
       }
    };

    /// to be able to compare strings in maps
    struct cmp_string
    {
       bool operator()(const std::string a, const std::string b) const
       {
          return std::strcmp(a.c_str(), b.c_str()) < 0;
       }
    };

    /// to be able to compare doubles considering epsilon
    struct cmp_eps_double
    {
        double eps;
        bool operator()(const double a, const double b) const
        {
            return a < b-(0.001);
        }

        // Default constructors
        cmp_eps_double(): eps(0.001)
        {}
        cmp_eps_double(double e): eps(e)
        {}
    };


    /* ///////////////////////////////////////////// */
    /// normalize a 3D vector such that ||v|| = 1
    /* ///////////////////////////////////////////// */
    void unit_normal(Vector&);

    /* /////////////////////////////////////////////////////////////////////////////////////// */
    /// Return the (unit) normal of a 3D polygon using Newell's method (works for concave poly)
    /* /////////////////////////////////////////////////////////////////////////////////////// */
    Vector poly_normal (const LCC&, Dart_handle, bool normalize = true);

    /* ////////////////////////////////////////////////////////// */
    /// Compute the AABB of a 3-cell
    /* ////////////////////////////////////////////////////////// */
    Bbox_3 Get_Bbox_vol (LCC&, Dart_handle);

    /* ///////////////////////////////////////////// */
    /// Generate a unique ID based on current time
    /* ///////////////////////////////////////////// */
    std::string generate_unique_ID();



    /* ////////////////////////////////////////////////////////////////////////////// */
    /// Return the angle between two 2D vectors v1 and v2, in the range [0°, 180°]
    /* ////////////////////////////////////////////////////////////////////////////// */
    double compute_3d_angle(const Vector&, const Vector&);


    /* //////////////////////////////////////////////////////////////////////////////// */
    /// Returns true if v1 and v2 are (eps_angle) colinear
    /* //////////////////////////////////////////////////////////////////////////////// */
    bool vectors_are_eps_colinear (Vector, Vector);


    /* /////////////////////////////////////////////////////////////////////////////////////// */
    /// Return the (unit) normal of a 3D polygon using Newell's method (works for concave poly)
    /* /////////////////////////////////////////////////////////////////////////////////////// */
    Vector poly_normal_vec3d (vec_pt3d&, bool);

    /* /////////////////////////////////////////////////////////////// */
    /// Compute the surface area of a LCC 3D polygon using Newell's normal
    /* /////////////////////////////////////////////////////////////// */
    double poly_surface_area(LCC&, Dart_handle);

    /* /////////////////////////////////////////////////////////////// */
    /// Compute the surface area of a LCC 3D polygon using Newell's normal
    /* /////////////////////////////////////////////////////////////// */
    double poly_surface_area_vec3d(vec_pt3d&);


    /* /////////////////////////////////////////////////////// */
    /// Print all the vertices of the given face
    /* /////////////////////////////////////////////////////// */
    void Print_face(const LCC&, Dart_handle);

    /* /////////////////////////////////////////////////////// */
    /// Print all the vertices of the given face (vec_pt3d)
    /* /////////////////////////////////////////////////////// */
    void Print_face_vec(vec_pt3d &);

    /* ////////////////////////////////////////////////////////////////////////////// */
    /// Returns true if two 3D points are epsilon equal
    /* ////////////////////////////////////////////////////////////////////////////// */
    bool Points_are_eps_close (const Point&, const Point&);

    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    /// Collect for each 1-cell of the LCC all the faces that are around and incident to it
    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    void Collect_faces_around_edges_dumb (LCC&, std::vector< vec_dart >&, vec_dart&);

    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    /// Overloaded version of the above function
    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    void Collect_faces_around_edges_dumb (LCC&, std::vector< vec_dart >&);


    /* ////////////////////////////////////////// */
    /// Counts the number of 2-free darts
    /* ////////////////////////////////////////// */
    bool There_are_2free_darts(LCC&, vec_dart&);


    /* ////////////////////////////////////////// */
    /// Overloaded version of the above function
    /* ////////////////////////////////////////// */
    bool There_are_2free_darts(LCC&);



    /* ////////////////////////////////////////////////////////// */
    /// Create a new face in the LCC based on a vector of points
    /* ////////////////////////////////////////////////////////// */
    Dart_handle Insert_new_2cell (LCC&, vec_pt3d&, bool orientation = true);

    /* ////////////////////////////////////////////////////////// */
    /// Generates a unique string key from a Point
    /* ////////////////////////////////////////////////////////// */
    std::string get_unique_key_pt( Point& );

    /* ////////////////////////////////////////////////////////// */
    /// Computes the AABB of a list of faces
    /* ////////////////////////////////////////////////////////// */
    Bbox_3 Get_Bbox_face_list (LCC&, vec_dart &);

    /* ////////////////////////////////////////////////////////// */
    /// Computes the AABB of a 3D face
    /* ////////////////////////////////////////////////////////// */
    Bbox_3 Get_Bbox_face (LCC&, Dart_handle);

    /* ////////////////////////////////////////////////////////// */
    /// Computes the AABB of a 3D LCC
    /* ////////////////////////////////////////////////////////// */
    Bbox_3 Get_Bbox_LCC (LCC&);

    /* ////////////////////////////////////////////////////////// */
    /// Returns true if the Bbox is degenerate (flat volume)
    /* ////////////////////////////////////////////////////////// */
    bool Bbox_is_degenerate(Bbox_3);

    /* ///////////////////////////////////////////////////////////////// */
    /// Resize the Bbox by increasing/decreasing it in all directions
    /* ///////////////////////////////////////////////////////////////// */
    void Rescale_Bbox (Bbox_3 &, double &, bool increase = true);


    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    /// Reconstructs a bunch of unstrucured polygons into closed volume(s)
    /// This method assumes that all the faces are well oriented
    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    bool Perform_Simple_Volume_Reconstruction_from_Polygon_Soup(LCC&, vec_dart&);

    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    /// Overloaded version of the function above
    /* ////////////////////////////////////////////////////////////////////////////////////////// */
    bool Perform_Simple_Volume_Reconstruction_from_Polygon_Soup(LCC&);

    /* ///////////////////////////////////////////////////////////////////////// */
    /// Tries to remove aligned points on edges by keeping only corner points
    /* ///////////////////////////////////////////////////////////////////////// */
    void Keep_corners_points_only (LCC&, vec_dart&);

    /* //////////////////////////////////////////////////////////////////////////////// */
    /// Remove a selected set of 0-cells from the LCC
    /* //////////////////////////////////////////////////////////////////////////////// */
    void Remove_selected_0_cells (LCC&, vec_dart&);

    /* //////////////////////////////////////////////////////////////////////////////// */
    /// Remove a selected set of 2-cells from the LCC
    /* //////////////////////////////////////////////////////////////////////////////// */
    void Remove_selected_2_cells (LCC&, vec_dart&);

    /* //////////////////////////////////////////////////////////////////////////////// */
    /// Remove a selected set of 3-cells from the LCC
    /* //////////////////////////////////////////////////////////////////////////////// */
    void Remove_selected_3_cells (LCC&, vec_dart&);


    /* ///////////////////////////////////////////////////////////////////////////////////////////// */
    /// Shift the min corner of the bbox of the model to the origin if the coordinates are too big
    /* ///////////////////////////////////////////////////////////////////////////////////////////// */
    void Apply_global_shifting (LCC&);


}



#endif // LCC_SPECIALOPS_H
